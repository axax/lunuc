/* generate sources */

const fs = require('fs')
const path = require('path')

const APP_CONFIG = require('./config.json')
const EXTENSION_PATH = './extensions/'
const GENSRC_HEADER = '/* this file was generated by webpack.config.js */\n\n'
const GENSRC_PATH = './gensrc';



function GenSourceCode(options) {
    this.compiled = false
}

GenSourceCode.prototype.apply = function (compiler) {
    compiler.plugin("compile", function (p) {
        if (this.compiled) return
        this.compiled = true

        /* generete source code */
        console.log('Generating source code')

        try {
            deleteFolderRecursive( path.resolve(__dirname, GENSRC_PATH) )
            fs.mkdirSync(GENSRC_PATH)
        } catch (err) {
            if (err.code !== 'EEXIST') throw err
        }

        const exteionsion = fs.readdirSync(EXTENSION_PATH)

        let clientContent = GENSRC_HEADER, serverContent = GENSRC_HEADER, manifestJson = {}

        exteionsion.forEach(file => {
            if (fs.statSync(EXTENSION_PATH + file).isDirectory()) {
                if (APP_CONFIG.extensions) {
                    const ext = APP_CONFIG.extensions[file]
                    if (ext && ext.active) {


                        if (fs.existsSync(EXTENSION_PATH + file + '/extension.json')) {
                            manifestJson[file] = JSON.parse(fs.readFileSync(EXTENSION_PATH + file + '/extension.json', 'utf8'));
                        } else {
                            manifestJson[file] = {name: file}
                        }

                        if (fs.existsSync(EXTENSION_PATH + file + '/build.json')) {
                            const buildOptions = require(EXTENSION_PATH + file + '/build.json')
                            manifestJson[file].options = buildOptions
                            gensrcExtension(file, buildOptions)
                        }

                        /*if (fs.existsSync(extensionFolder + file + '/build.js')) {
                         const extensionBuild = require(extensionFolder + file + '/build.js')
                         const buildOptions = extensionBuild()
                         gensrcExtension(file,buildOptions)
                         }*/



                        if (fs.existsSync(EXTENSION_PATH + file + '/client.js')) {
                            clientContent += `import '.${EXTENSION_PATH}${file}/client.js'\n`
                        }
                        if (fs.existsSync(EXTENSION_PATH + file + '/server.js')) {
                            serverContent += `import '.${EXTENSION_PATH}${file}/server.js'\n`
                        }


                    }
                }
            }
        })

        const manifestStr = `${GENSRC_HEADER}const extensions=${JSON.stringify(manifestJson, null, 4)}\nexport default extensions`

        fs.writeFile(GENSRC_PATH + "/extensions.js", manifestStr, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        fs.writeFile(GENSRC_PATH + "/extensions-client.js", clientContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })
        fs.writeFile(GENSRC_PATH + "/extensions-server.js", serverContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        /* generate config */
        let configContent = `${GENSRC_HEADER}export const APOLLO_CACHE=${APP_CONFIG.apollo_cache || true}\n`
        configContent += `export const DEBUG=${APP_CONFIG.debug || true}\nexport const ADMIN_BASE_URL='${APP_CONFIG.admin_base_url || ''}'`

        fs.writeFile(GENSRC_PATH + "/config.js", configContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })


        /* ui */
        gensrcUi()


    })

}




function gensrcUi() {


    /* generate ui source */
    if (APP_CONFIG.ui) {


        const gendirUi = GENSRC_PATH + '/ui'
        try {
            fs.mkdirSync(gendirUi)
        } catch (err) {
            if (err.code !== 'EEXIST') throw err
        }

        APP_CONFIG.ui.forEach((ui) => {
            let gendirUiName = gendirUi
            if( ui.name ){
                gendirUiName +='/'+ui.name
                try {
                    fs.mkdirSync(gendirUiName)
                } catch (err) {
                    if (err.code !== 'EEXIST') throw err
                }
            }


            let uiContentIconsHooks = ''
            let uiContentIcons = `import React from 'react'\nimport Hook from 'util/hook'\n`
            let uiContent = `${GENSRC_HEADER}export * from 'client/components/ui/impl/${ui.impl || 'material'}/index'\n${GENSRC_HEADER}export * from './icons'\n`

            if (ui.icons) {
                if (ui.impl === 'material') {
                    uiContentIcons += "import MaterialIconButton from 'material-ui/IconButton'\n"
                }

                //https://github.com/mui-org/material-ui/tree/v1-beta/packages/material-ui-icons/src
                ui.icons.forEach(icon => {
                    if (ui.impl === 'material') {
                        uiContentIcons += `
import ${icon}Icon from 'material-ui-icons/${icon}'

export const ${icon}IconButton = ({...rest}) => {
    return <MaterialIconButton{...rest} >
        <${icon}Icon />
    </MaterialIconButton>
}
`
                        uiContentIconsHooks += `components['${icon}Icon'] = ${icon}Icon\ncomponents['${icon}IconButton'] = ${icon}IconButton\n`

                    }
                })
            }
            uiContentIcons += `Hook.on('JsonDom', ({components}) => {\n${uiContentIconsHooks}})`

            fs.writeFile(gendirUiName + '/icons.js', uiContentIcons, function (err) {
                if (err) {
                    return console.log(err)
                }
            })
            fs.writeFile(gendirUiName + "/index.js", uiContent, function (err) {
                if (err) {
                    return console.log(err)
                }
            })
        })
    }
}

function gensrcExtension(name, options) {
    if (!options) return

    const gendir = EXTENSION_PATH + name + '/' + GENSRC_PATH
    try {
        deleteFolderRecursive( path.resolve(__dirname, gendir) )
        fs.mkdirSync(gendir)
    } catch (err) {
        if (err.code !== 'EEXIST') throw err
    }

    if (options && options.types) {

        let schema = GENSRC_HEADER+'export default `\n'
        let resolver = GENSRC_HEADER+`import GenericResolver from 'api/resolver/generic/genericResolver'\n\nexport default db => ({\n`
        options.types.forEach((type) => {
            const nameStartLower = type.name.charAt(0).toLowerCase() + type.name.slice(1)
            schema += 'type ' + type.name + '{\n'
            schema += '\t_id: ID!\n\tcreatedBy: UserPublic!\n\tstatus: String\n'

            let mutationFields = '', resolverFields = ''

            type.fields.forEach((field) => {
                const type = (field.type || 'String')
                const fieldPair = field.name + ':' + type
                if (type.indexOf('[') < 0) {
                    if (mutationFields !== '') mutationFields += ','
                    if (resolverFields !== '') resolverFields += ','

                    mutationFields += fieldPair
                    resolverFields += `'${field.name}'`
                }
                schema += '\t'+fieldPair + '\n'
            })

            schema += '}\n\n'


            schema += 'type ' + type.name + 'Result {\n\tresults: [' + type.name + ']\n\toffset: Int\n\tlimit: Int\n\ttotal: Int\n}\n\n'

            schema += 'type Query {\n\t' + nameStartLower + 's(sort: String, limit: Int=10, offset: Int=0, filter: String): ' + type.name + 'Result\n}\n\n'


            schema += 'type Mutation {\n'
            schema += '\tcreate' + type.name + ' (' + mutationFields + '):' + type.name + '\n'
            schema += '\tupdate' + type.name + ' (_id: ID!' + (mutationFields.length > 0 ? ',' : '') + mutationFields + '):' + type.name + '\n'
            schema += '\tdelete' + type.name + ' (_id: ID!):' + type.name + '\n'
            schema += '}\n\n'

            resolver += `   ${nameStartLower}: async ({sort, limit, offset, filter}, {context}) => {
        return await GenericResolver.entities(db, context, '${type.name}', [${resolverFields}], {limit, offset, filter, sort})
    },
    create${type.name}: async ({...rest}, {context}) => {
        return await GenericResolver.createEnity(db, context, '${type.name}', {...rest})
    },
    update${type.name}: async ({...rest}, {context}) => {
        return GenericResolver.updateEnity(db, context, '${type.name}', {...rest})
    },
    delete${type.name}: async ({_id}, {context}) => {
        return GenericResolver.deleteEnity(db, context, '${type.name}', {_id})
    },\n`


        })
        schema += '`\n'
        resolver += `})`

        fs.writeFile(gendir + "/schema.js", schema, function (err) {
            if (err) {
                console.log(err)
            }
        })
        fs.writeFile(gendir + "/resolver.js", resolver, function (err) {
            if (err) {
                console.log(err)
            }
        })


    }

}

const deleteFolderRecursive = function(path) {
    if (fs.existsSync(path)) {
        fs.readdirSync(path).forEach(function(file, index){
            var curPath = path + "/" + file
            if (fs.lstatSync(curPath).isDirectory()) { // recurse
                deleteFolderRecursive(curPath)
            } else { // delete file
                console.log('delete file '+curPath)
                fs.unlinkSync(curPath)
            }
        });
        fs.rmdirSync(path)
    }
}





module.exports = GenSourceCode

/* generate sources */

const fs = require('fs')
const path = require('path')

const APP_CONFIG = require('./buildconfig.json')
const EXTENSION_PATH = './extensions/'
const GENSRC_HEADER = '/* this file was generated by webpack.config.js */\n\n'
const GENSRC_PATH = './gensrc';
const DEV_MODE = process.env.NODE_ENV !== 'production' && process.argv.indexOf('-p') === -1

const COMMON_MONGO_TYPES = ['String', 'Int', 'ID', 'Float', 'Boolean']

var APP_VALUES = false

function GenSourceCode(o) {
    APP_VALUES = o
}

GenSourceCode.prototype.apply = function (compiler) {
    compiler.plugin("compile", function (p) {
        if (this.compiled) return
        this.compiled = true

        /* generete source code */
        console.log('Generating source code')

        try {
            deleteFolderRecursive(path.resolve(__dirname, GENSRC_PATH))
            fs.mkdirSync(GENSRC_PATH)
        } catch (err) {
            if (err.code !== 'EEXIST') throw err
        }

        const exteionsion = fs.readdirSync(EXTENSION_PATH)

        let clientContent = GENSRC_HEADER, serverContent = GENSRC_HEADER, manifestJson = {}

        clientContent += '\nconst settings = (_app_.localSettings && _app_.localSettings.extensions) || {}\n\n'

        exteionsion.forEach(file => {
            if (fs.statSync(EXTENSION_PATH + file).isDirectory()) {
                if (APP_CONFIG.extensions) {
                    const ext = APP_CONFIG.extensions[file]
                    if (ext && ext.active) {


                        if (fs.existsSync(EXTENSION_PATH + file + '/extension.json')) {
                            manifestJson[file] = JSON.parse(fs.readFileSync(EXTENSION_PATH + file + '/extension.json', 'utf8'));
                            //TODO: implement dependency check
                        } else {
                            manifestJson[file] = {name: file}
                        }

                        if (fs.existsSync(EXTENSION_PATH + file + '/build.json')) {
                            const buildOptions = require(EXTENSION_PATH + file + '/build.json')

                            // genearte source for backend
                            gensrcExtension(file, buildOptions)

                            // remove hidden fields as we don't want theme to be exposed to the frontend
                            if (buildOptions.types) {
                                buildOptions.types.forEach(type => {
                                    type.fields = type.fields.filter(field => !field.hidden)
                                })
                            }

                            manifestJson[file].options = buildOptions
                        }

                        if (manifestJson[file].options && manifestJson[file].options.types) {

                            manifestJson[file].options.types.forEach(type => {

                                type.fields = type.fields.map(field => {
                                    if (field.type && COMMON_MONGO_TYPES.indexOf(field.type) < 0) {
                                        // this is a type reference
                                        field.reference = true
                                    }
                                    return field
                                })

                            })

                        }

                        /*if (fs.existsSync(extensionFolder + file + '/build.js')) {
                         const extensionBuild = require(extensionFolder + file + '/build.js')
                         const buildOptions = extensionBuild()
                         gensrcExtension(file,buildOptions)
                         }*/

                        if (fs.existsSync(EXTENSION_PATH + file + '/client.js')) {
                            if (manifestJson[file].lazyLoad) {
                                clientContent += `//load lazy
import(/* webpackChunkName: "${file}" */ '.${EXTENSION_PATH}${file}/client.js')
`
                            } else {
                                clientContent += `import ${file} from '.${EXTENSION_PATH}${file}/client.js'\nif(typeof ${file} === "function" && (!settings['${file}'] || settings['${file}'].enabled)){\n\t${file}()\n}\n`
                            }
                        }
                        if (fs.existsSync(EXTENSION_PATH + file + '/server.js')) {
                            serverContent += `import '.${EXTENSION_PATH}${file}/server.js'\n`
                        }


                    }
                }
            }
        })

        const manifestStr = `${GENSRC_HEADER}const extensions=${JSON.stringify(manifestJson, null, 4)}\nexport default extensions`

        fs.writeFile(GENSRC_PATH + "/extensions.js", manifestStr, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        fs.writeFile(GENSRC_PATH + "/extensions-client.js", clientContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })
        fs.writeFile(GENSRC_PATH + "/extensions-server.js", serverContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        /* generate config */
        let configContent = `${GENSRC_HEADER}export default ${JSON.stringify(Object.assign({}, APP_CONFIG.options, APP_VALUES))}\n`
        fs.writeFile(GENSRC_PATH + "/config.js", configContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        /* create schema */
        let schemaContent = `${GENSRC_HEADER}export default \`type LocalizedString {\n\t${APP_CONFIG.options.LANGUAGES.join(': String\n\t')}: String\n}\n\ninput LocalizedStringInput {\n\t${APP_CONFIG.options.LANGUAGES.join(': String\n\t')}: String\n}\``
        fs.writeFile(GENSRC_PATH + "/schema.js", schemaContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })


        /* ui */
        gensrcUi()


    })

}


function gensrcUi() {


    /* generate ui source */
    if (APP_CONFIG.ui) {


        const gendirUi = GENSRC_PATH + '/ui'
        try {
            fs.mkdirSync(gendirUi)
        } catch (err) {
            if (err.code !== 'EEXIST') throw err
        }


        fs.writeFile(gendirUi + "/variables.less", '', function (err) {
            if (err) {
                return console.log(err)
            }
        })

        APP_CONFIG.ui.forEach((ui) => {
            let gendirUiName = gendirUi
            if (ui.name) {
                gendirUiName += '/' + ui.name
                try {
                    fs.mkdirSync(gendirUiName)
                } catch (err) {
                    if (err.code !== 'EEXIST') throw err
                }
            }


            let uiContentIconsHooks = ''
            let uiContentIcons = `import React from 'react'\nimport Hook from 'util/hook'\n`


            //let uiContent = `${GENSRC_HEADER}import(/* webpackChunkName: "admin" */ '${ui.name?'../':''}../../client/components/ui/impl/${ui.impl || 'material'}/index')`
            //uiContent += `${GENSRC_HEADER}\nexport * from './icons'\n`

            let uiContent = `${GENSRC_HEADER}export * from 'client/components/ui/impl/${ui.impl || 'material'}/index'\nexport * from './icons'\n`


            if (ui.icons) {
                if (ui.impl === 'material') {
                    uiContentIcons += "import IconButton from '@material-ui/core/IconButton'\n"
                }

                //https://github.com/mui-org/material-ui/tree/v1-beta/packages/material-ui-icons/src
                ui.icons.forEach(icon => {
                    if (ui.impl === 'material') {
                        uiContentIcons += `
import ${icon}Icon from '@material-ui/icons/${icon}'
export {${icon}Icon}

export const ${icon}IconButton = ({...rest}) => {
    return <IconButton{...rest} >
        <${icon}Icon />
    </IconButton>
}
`
                        uiContentIconsHooks += `components['${icon}Icon'] = ${icon}Icon\ncomponents['${icon}IconButton'] = ${icon}IconButton\n`

                    }else{
                        uiContentIcons +=  `
export const ${icon}Icon = ({...rest}) => {
    return <div className="Icon Icon-${icon}" {...rest} />
}
export const ${icon}IconButton = ({...rest}) => {
    return <button className="IconButton ${icon}IconButton"{...rest} >
        <${icon}Icon /> ${icon}
    </button>
}
`
                    }
                })
            }
            uiContentIcons += `Hook.on('JsonDom', ({components}) => {\n${uiContentIconsHooks}})`

            fs.writeFile(gendirUiName + '/icons.js', uiContentIcons, function (err) {
                if (err) {
                    return console.log(err)
                }
            })
            fs.writeFile(gendirUiName + "/index.js", uiContent, function (err) {
                if (err) {
                    return console.log(err)
                }
            })
        })
    }
}

function gensrcExtension(name, options) {
    if (!options) return


    const gendir = EXTENSION_PATH + name + '/' + GENSRC_PATH
    try {
        deleteFolderRecursive(path.resolve(__dirname, gendir))
    } catch (err) {
        if (err.code !== 'EEXIST') throw err
    }

    if (options && options.types) {


        let schema = GENSRC_HEADER + 'export default `\n'
        let resolver = GENSRC_HEADER + `import {ObjectId} from 'mongodb'\nimport {pubsub} from 'api/subscription'\nimport {withFilter} from 'graphql-subscriptions'\n`
        resolver += `import GenericResolver from 'api/resolver/generic/genericResolver'\n\nexport default db => ({\n`
        let resolverQuery = '\tQuery:{\n'
        let resolverMutation = '\tMutation:{\n'
        let resolverSubscription = '\tSubscription:{\n'
        let hasResolver = false, hasSchema = false
        options.types.forEach((type) => {

            const nameStartLower = type.name.charAt(0).toLowerCase() + type.name.slice(1)

            let typeSchema = 'type ' + type.name + '{\n'
            typeSchema += '\t_id: ID!' + (!type.noUserRelation ? '\n\tcreatedBy:UserPublic!' : '') + '\n\tstatus: String\n'

            let mutationFields = '', resolverFields = '', refResolvers = '', refResolversObjectId = ''

            type.fields.forEach((field) => {
                if (field.name.trim().toLowerCase().endsWith('_localized')) {
                    throw Error('A filed name is not allowed to end with the string _localized. This is reserved for localized fields')
                }

                const type = (field.type || 'String')
                let isRef = false


                if (COMMON_MONGO_TYPES.indexOf(type) < 0) {
                    // it might be a reference so we only need to store the ID
                    isRef = true
                    if (refResolvers !== '') refResolvers += ','
                    if (refResolversObjectId !== '') refResolversObjectId += ','
                    refResolvers += field.name
                    if (field.multi) {
                        refResolversObjectId += field.name + ':' + '(' + field.name + '?' + field.name + '.reduce((o,id)=>{o.push(ObjectId(id));return o},[]):' + field.name + ')'

                    } else {
                        refResolversObjectId += field.name + ':' + '(' + field.name + '?' + 'ObjectId(' + field.name + '):' + field.name + ')'
                    }
                }

                if (mutationFields !== '') mutationFields += ','
                if (resolverFields !== '') resolverFields += ','

                mutationFields += field.name + ':' + (field.multi ? '[' : '') + (isRef ? 'ID' : type) + (field.multi ? ']' : '')
                resolverFields += '\'' + field.name + (isRef ? '$' + (field.multi ? '[' : '') + type + (field.multi ? ']' : '') : '') + '\''

                typeSchema += '\t' + field.name + ':' + (field.multi ? '[' : '') + type + (field.multi ? ']' : '') + '\n'


                if (field.localized && !field.multi) { // no support for multi yet
                    typeSchema += '\t' + field.name + '_localized: LocalizedString\n'
                    resolverFields += ',\'' + field.name + '_localized\''
                    mutationFields += ',' + field.name + '_localized: LocalizedStringInput'
                }
            })

            if (type.collectionClonable) {
                mutationFields += ',_version:String'
            }

            typeSchema += '}\n\n'


            typeSchema += 'type ' + type.name + 'Result{\n\tresults:[' + type.name + ']\n\toffset:Int\n\tlimit:Int\n\ttotal:Int\n}\n\n'

            let mutationResult = type.mutationResult
            if( !mutationResult ) {
                mutationResult = type.name + 'Status'
                // if a mutationResult is set we return that otherwise we return a simple Status object

                // Maybe it is better to return only a Status instead of the whole type when create, update or delete is performed
                typeSchema += 'type ' + mutationResult + '{\n\t_id:ID!\n\tstatus:String\n}\n\n'
            }
            typeSchema += 'type Query{\n\t' + nameStartLower + 's(sort:String,limit:Int=10,offset:Int=0,page:Int=0,filter:String' + (type.collectionClonable ? ',_version:String' : '') + '): ' + type.name + 'Result\n}\n\n'


            typeSchema += 'type Mutation{\n'
            typeSchema += '\tcreate' + type.name + ' (' + mutationFields + '):' + mutationResult + '\n'
            typeSchema += '\tupdate' + type.name + ' (_id:ID!' + (mutationFields.length > 0 ? ',' : '') + mutationFields + '):' + mutationResult + '\n'
            typeSchema += '\tdelete' + type.name + ' (_id:ID!' + (type.collectionClonable ? ',_version:String' : '') + '):' + mutationResult + '\n'
            typeSchema += '\tdelete' + type.name + 's (_id:[ID]' + (type.collectionClonable ? ',_version:String' : '') + '):[' + mutationResult + ']\n'
            if (type.collectionClonable) {
                typeSchema += '\tclone' + type.name + ' (_id:ID!' + (mutationFields.length > 0 ? ',' : '') + mutationFields + '):' + type.name + '\n'
            }
            typeSchema += '}\n\n'

            typeSchema += 'type ' + type.name + 'SubscribeResult {\n\tdata:' + type.name + '\n\taction:String\n}\n\n'


            typeSchema += 'type Subscription{\n'
            typeSchema += '    subscribe' + type.name + ': ' + type.name + 'SubscribeResult\n'
            typeSchema += '}\n\n'


            if (type.genSchema === false) {
                console.log('genSchema for type ' + type.name + ' was explicitly set to false')
            } else {
                hasSchema = true
                schema += typeSchema
            }

            if (type.genResolver === false) {
                console.log('genResolver for type ' + type.name + ' was explicitly set to false')
            } else {
                hasResolver = true

                resolverQuery += `      ${nameStartLower}s: async ({sort, limit, offset, page, filter}, {context}) => {
            return await GenericResolver.entities(db, context, '${type.name}', [${resolverFields}], {limit, offset, page, filter, sort})
        },\n`

                resolverMutation += `       create${type.name}: async ({${refResolvers}${refResolvers !== '' ? ',' : ''}...rest}, {context}) => {
            pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'create',data:{...rest}}})
            return await GenericResolver.createEnity(db, context, '${type.name}', {...rest,${refResolversObjectId}})
        },
        update${type.name}: async ({${refResolvers}${refResolvers !== '' ? ',' : ''}...rest}, {context}) => {
            pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'update', data: {...rest}}})
            return GenericResolver.updateEnity(db, context, '${type.name}', {...rest,${refResolversObjectId}})
        },
        delete${type.name}: async ({_id}, {context}) => {
             pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'delete', data: {_id}}})
            return GenericResolver.deleteEnity(db, context, '${type.name}', {_id})
        },
        delete${type.name}s: async ({_id}, {context}) => {
             pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'delete', data: {_id}}})
            return GenericResolver.deleteEnities(db, context, '${type.name}', {_id})
        },\n`
                resolverSubscription += `       subscribe${type.name}: withFilter(() => pubsub.asyncIterator('subscribe${type.name}'),
            (payload, context) => {
                if( payload ) {
                    //return payload.userId === context.id
                    return true
                }
            }
        ),\n`
            }


        })
        schema += '`\n'
        resolver += resolverQuery + '\t},\n' + resolverMutation + '\t},\n' + resolverSubscription + `\t}\n})`

        if (hasSchema || hasResolver) {
            try {
                fs.mkdirSync(gendir)
            } catch (err) {
                if (err.code !== 'EEXIST') throw err
            }
            if (hasSchema) {
                fs.writeFile(gendir + "/schema.js", schema, function (err) {
                    if (err) {
                        console.log(err)
                    }
                })
            }
            if (hasResolver) {
                fs.writeFile(gendir + "/resolver.js", resolver, function (err) {
                    if (err) {
                        console.log(err)
                    }
                })
            }
        }


    }

}

const deleteFolderRecursive = function (path) {
    if (fs.existsSync(path)) {
        fs.readdirSync(path).forEach(function (file, index) {
            var curPath = path + "/" + file
            if (fs.lstatSync(curPath).isDirectory()) { // recurse
                deleteFolderRecursive(curPath)
            } else { // delete file
                console.log('delete file ' + curPath)
                fs.unlinkSync(curPath)
            }
        });
        fs.rmdirSync(path)
    }
}


module.exports = GenSourceCode

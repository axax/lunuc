/* generate sources */

const fs = require('fs')
const path = require('path')

const APP_CONFIG = require('./config.json')
const EXTENSION_PATH = './extensions/'
const GENSRC_HEADER = '/* this file was generated by webpack.config.js */\n\n'
const GENSRC_PATH = './gensrc';
const DEV_MODE = process.env.NODE_ENV !== 'production' && process.argv.indexOf('-p') === -1


const COMMON_MONGO_TYPES = ['String', 'Int', 'ID', 'Float', 'Boolean']


function GenSourceCode(options) {
    this.compiled = false
}

GenSourceCode.prototype.apply = function (compiler) {
    compiler.plugin("compile", function (p) {
        if (this.compiled) return
        this.compiled = true

        /* generete source code */
        console.log('Generating source code')

        try {
            deleteFolderRecursive(path.resolve(__dirname, GENSRC_PATH))
            fs.mkdirSync(GENSRC_PATH)
        } catch (err) {
            if (err.code !== 'EEXIST') throw err
        }

        const exteionsion = fs.readdirSync(EXTENSION_PATH)

        let clientContent = GENSRC_HEADER, serverContent = GENSRC_HEADER, manifestJson = {}

        exteionsion.forEach(file => {
            if (fs.statSync(EXTENSION_PATH + file).isDirectory()) {
                if (APP_CONFIG.extensions) {
                    const ext = APP_CONFIG.extensions[file]
                    if (ext && ext.active) {


                        if (fs.existsSync(EXTENSION_PATH + file + '/extension.json')) {
                            manifestJson[file] = JSON.parse(fs.readFileSync(EXTENSION_PATH + file + '/extension.json', 'utf8'));
                        } else {
                            manifestJson[file] = {name: file}
                        }

                        if (fs.existsSync(EXTENSION_PATH + file + '/build.json')) {
                            const buildOptions = require(EXTENSION_PATH + file + '/build.json')
                            manifestJson[file].options = buildOptions
                            gensrcExtension(file, buildOptions)
                        }

                        if (manifestJson[file].options && manifestJson[file].options.types) {

                            manifestJson[file].options.types.forEach(type => {

                                type.fields = type.fields.map(field => {
                                    if (field.type && COMMON_MONGO_TYPES.indexOf(field.type) < 0) {
                                        // this is a type reference
                                        field.reference = true
                                    }
                                    return field
                                })

                            })

                        }

                        /*if (fs.existsSync(extensionFolder + file + '/build.js')) {
                         const extensionBuild = require(extensionFolder + file + '/build.js')
                         const buildOptions = extensionBuild()
                         gensrcExtension(file,buildOptions)
                         }*/


                        if (fs.existsSync(EXTENSION_PATH + file + '/client.js')) {
                            clientContent += `import '.${EXTENSION_PATH}${file}/client.js'\n`
                        }
                        if (fs.existsSync(EXTENSION_PATH + file + '/server.js')) {
                            serverContent += `import '.${EXTENSION_PATH}${file}/server.js'\n`
                        }


                    }
                }
            }
        })

        const manifestStr = `${GENSRC_HEADER}const extensions=${JSON.stringify(manifestJson, null, 4)}\nexport default extensions`

        fs.writeFile(GENSRC_PATH + "/extensions.js", manifestStr, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        fs.writeFile(GENSRC_PATH + "/extensions-client.js", clientContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })
        fs.writeFile(GENSRC_PATH + "/extensions-server.js", serverContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        /* generate config */
        const o ={DEV_MODE}
        let configContent = `${GENSRC_HEADER}export default ${JSON.stringify(Object.assign({},APP_CONFIG.options,o))}\n`
        fs.writeFile(GENSRC_PATH + "/config.js", configContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        /* create schema */
        let schemaContent = `${GENSRC_HEADER}export default \`type LocalizedString {\n\t${APP_CONFIG.options.LANGUAGES.join(': String\n\t')}: String\n}\``
        fs.writeFile(GENSRC_PATH + "/schema.js", schemaContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })


        /* ui */
        gensrcUi()


    })

}


function gensrcUi() {


    /* generate ui source */
    if (APP_CONFIG.ui) {


        const gendirUi = GENSRC_PATH + '/ui'
        try {
            fs.mkdirSync(gendirUi)
        } catch (err) {
            if (err.code !== 'EEXIST') throw err
        }


        fs.writeFile(gendirUi + "/variables.less", '', function (err) {
            if (err) {
                return console.log(err)
            }
        })

        APP_CONFIG.ui.forEach((ui) => {
            let gendirUiName = gendirUi
            if (ui.name) {
                gendirUiName += '/' + ui.name
                try {
                    fs.mkdirSync(gendirUiName)
                } catch (err) {
                    if (err.code !== 'EEXIST') throw err
                }
            }


            let uiContentIconsHooks = ''
            let uiContentIcons = `import React from 'react'\nimport Hook from 'util/hook'\n`
            let uiContent = `${GENSRC_HEADER}export * from 'client/components/ui/impl/${ui.impl || 'material'}/index'\nexport * from './icons'\n`

            if (ui.icons) {
                if (ui.impl === 'material') {
                    uiContentIcons += "import IconButton from 'material-ui/IconButton'\n"
                }

                //https://github.com/mui-org/material-ui/tree/v1-beta/packages/material-ui-icons/src
                ui.icons.forEach(icon => {
                    if (ui.impl === 'material') {
                        uiContentIcons += `
import ${icon}Icon from 'material-ui-icons/${icon}'
export {${icon}Icon}

export const ${icon}IconButton = ({...rest}) => {
    return <IconButton{...rest} >
        <${icon}Icon />
    </IconButton>
}
`
                        uiContentIconsHooks += `components['${icon}Icon'] = ${icon}Icon\ncomponents['${icon}IconButton'] = ${icon}IconButton\n`

                    }
                })
            }
            uiContentIcons += `Hook.on('JsonDom', ({components}) => {\n${uiContentIconsHooks}})`

            fs.writeFile(gendirUiName + '/icons.js', uiContentIcons, function (err) {
                if (err) {
                    return console.log(err)
                }
            })
            fs.writeFile(gendirUiName + "/index.js", uiContent, function (err) {
                if (err) {
                    return console.log(err)
                }
            })
        })
    }
}

function gensrcExtension(name, options) {
    if (!options) return

    const gendir = EXTENSION_PATH + name + '/' + GENSRC_PATH
    try {
        deleteFolderRecursive(path.resolve(__dirname, gendir))
        fs.mkdirSync(gendir)
    } catch (err) {
        if (err.code !== 'EEXIST') throw err
    }

    if (options && options.types) {


        let schema = GENSRC_HEADER + 'export default `\n'
        let resolver = GENSRC_HEADER + `import {ObjectId} from 'mongodb'\nimport {pubsub} from 'api/subscription'\nimport {withFilter} from 'graphql-subscriptions'\n`
        resolver += `import GenericResolver from 'api/resolver/generic/genericResolver'\n\nexport default db => ({\n`
        options.types.forEach((type) => {
            const nameStartLower = type.name.charAt(0).toLowerCase() + type.name.slice(1)
            schema += 'type ' + type.name + '{\n'
            schema += '\t_id: ID!\n\tcreatedBy: UserPublic!\n\tstatus: String\n'

            let mutationFields = '', resolverFields = '', refResolvers = '', refResolversObjectId = ''

            type.fields.forEach((field) => {
                const type = (field.type || 'String')
                let isRef = false


                if (COMMON_MONGO_TYPES.indexOf(type) < 0) {
                    // it might be a reference so we only need to store the ID
                    isRef = true
                    if (refResolvers !== '') refResolvers += ','
                    if (refResolversObjectId !== '') refResolversObjectId += ','
                    refResolvers += field.name
                    if (field.multi) {
                        refResolversObjectId += field.name + ':' + '(' + field.name + '?' + field.name + '.reduce((o,id) => {o.push(ObjectId(id)); return o},[]):' + field.name + ')'

                    } else {
                        refResolversObjectId += field.name + ':' + '(' + field.name + '?' + 'ObjectId(' + field.name + '):' + field.name + ')'
                    }
                }

                if (mutationFields !== '') mutationFields += ','
                if (resolverFields !== '') resolverFields += ','

                mutationFields += field.name + ':' + (field.multi ? '[' : '') + (isRef ? 'ID' : type) + (field.multi ? ']' : '')
                resolverFields += '\'' + field.name + (isRef ? '$' + (field.multi ? '[' : '') + type + (field.multi ? ']' : '') : '') + '\''

                schema += '\t' + field.name + ':' + (field.multi ? '[' : '') + type + (field.multi ? ']' : '') + '\n'


                if( field.localized ){
                    schema += '\t' + field.name + '_localized: LocalizedString\n'
                    resolverFields += ',\''+field.name+'_localized\''
                }
            })

            schema += '}\n\n'


            schema += 'type ' + type.name + 'Result {\n\tresults: [' + type.name + ']\n\toffset: Int\n\tlimit: Int\n\ttotal: Int\n}\n\n'

            // Maybe it is better to return only a Status instead of the whole type when create, update or delete is performed
            schema += 'type ' + type.name + 'Status {\n\t_id: ID!\n\tstatus: String\n}\n\n'

            schema += 'type Query {\n\t' + nameStartLower + 's(sort: String, limit: Int=10, offset: Int=0, page: Int=0, filter: String): ' + type.name + 'Result\n}\n\n'


            schema += 'type Mutation {\n'
            schema += '\tcreate' + type.name + ' (' + mutationFields + '):' + type.name + 'Status\n'
            schema += '\tupdate' + type.name + ' (_id: ID!' + (mutationFields.length > 0 ? ',' : '') + mutationFields + '):' + type.name + 'Status\n'
            schema += '\tdelete' + type.name + ' (_id: ID!):' + type.name + 'Status\n'
            schema += '}\n\n'

            schema += 'type ' + type.name + 'SubscribeResult {\n\tdata:' + type.name + '\n\taction: String\n}\n\n'


            schema += 'type Subscription {\n'
            schema += '    subscribe' + type.name + ': ' + type.name + 'SubscribeResult\n'
            schema += '}\n\n'

            resolver += `   ${nameStartLower}s: async ({sort, limit, offset, page, filter}, {context}) => {
        return await GenericResolver.entities(db, context, '${type.name}', [${resolverFields}], {limit, offset, page, filter, sort})
    },
    create${type.name}: async ({...rest,${refResolvers}}, {context}) => {
        pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'create',data:{...rest}}})
        return await GenericResolver.createEnity(db, context, '${type.name}', {...rest,${refResolversObjectId}})
    },
    update${type.name}: async ({...rest,${refResolvers}}, {context}) => {
        pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'update', data: {...rest}}})
        return GenericResolver.updateEnity(db, context, '${type.name}', {...rest,${refResolversObjectId}})
    },
    delete${type.name}: async ({_id}, {context}) => {
         pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'delete', data: {_id}}})
        return GenericResolver.deleteEnity(db, context, '${type.name}', {_id})
    },
    subscribe${type.name}: withFilter(() => pubsub.asyncIterator('subscribe${type.name}'),
		(payload, context) => {
            if( payload ) {
                //return payload.userId === context.id
                return true
            }
		}
	),\n`


        })
        schema += '`\n'
        resolver += `})`

        fs.writeFile(gendir + "/schema.js", schema, function (err) {
            if (err) {
                console.log(err)
            }
        })
        fs.writeFile(gendir + "/resolver.js", resolver, function (err) {
            if (err) {
                console.log(err)
            }
        })


    }

}

const deleteFolderRecursive = function (path) {
    if (fs.existsSync(path)) {
        fs.readdirSync(path).forEach(function (file, index) {
            var curPath = path + "/" + file
            if (fs.lstatSync(curPath).isDirectory()) { // recurse
                deleteFolderRecursive(curPath)
            } else { // delete file
                console.log('delete file ' + curPath)
                fs.unlinkSync(curPath)
            }
        });
        fs.rmdirSync(path)
    }
}


module.exports = GenSourceCode

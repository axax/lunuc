/* generate sources */

const fs = require('fs')
const path = require('path')

let APP_CONFIG

const APP_CONFIG_DEFAULT = require('./buildconfig.json')

if (fs.existsSync('/etc/lunuc/buildconfig.json')) {
    APP_CONFIG = require('/etc/lunuc/buildconfig.json')

    // add missing icons from default
    if(APP_CONFIG_DEFAULT?.ui?.[0]?.icons){
        if(!APP_CONFIG.ui){
            APP_CONFIG.ui = []
        }
        if(!APP_CONFIG.ui.length===0){
            APP_CONFIG.ui.push({})
        }
        if(!APP_CONFIG.ui[0].icons){
            APP_CONFIG.ui[0].icons = []
        }
        APP_CONFIG_DEFAULT.ui[0].icons.forEach(icon=>{
            if(APP_CONFIG.ui[0].icons.indexOf(icon)<0){
                APP_CONFIG.ui[0].icons.push(icon)
            }
        })
    }
}else{
    APP_CONFIG = APP_CONFIG_DEFAULT
}

const EXTENSION_PATH = './extensions/'
const GENSRC_HEADER = '/* this file was generated by webpack.config.js */\n\n'
const GENSRC_PATH = './gensrc';
const DEV_MODE = process.env.NODE_ENV !== 'production' && process.argv.indexOf('-p') === -1

const COMMON_MONGO_TYPES = ['String', 'Int', 'ID', 'Float', 'Boolean', 'Object']

var APP_VALUES = false

function GenSourceCode(o) {
    APP_VALUES = o
}

GenSourceCode.prototype.apply = function (compiler) {

    compiler.hooks.compile.tap('Gensources', function (p) {
        if (this.compiled) return
        this.compiled = true

        /* generete source code */
        console.log('Generating source code')

        try {
            deleteFolderRecursive(path.resolve(__dirname, GENSRC_PATH))
            fs.mkdirSync(GENSRC_PATH)
        } catch (err) {
            if (err.code !== 'EEXIST') throw err
        }

        const exteionsion = fs.readdirSync(EXTENSION_PATH)

        let clientContent = GENSRC_HEADER, serverContent = GENSRC_HEADER, manifestJson = {},
            clientAdminContent = GENSRC_HEADER

        let base = '\nconst settings = (_app_.localSettings && _app_.localSettings.extensions) || {}\n'
        base += 'const start = (f, s)=>{if(typeof f === "function" && (!settings[s] || settings[s].enabled)){f()}}\n\n'

        clientContent += base

        clientAdminContent += base

        const extensionConfigs = {}

        for (const file of exteionsion) {
            if (fs.statSync(EXTENSION_PATH + file).isDirectory()) {
                if (APP_CONFIG.extensions) {
                    const ext = APP_CONFIG.extensions[file]
                    if (ext && ext.active) {


                        if (fs.existsSync(EXTENSION_PATH + file + '/extension.json')) {
                            manifestJson[file] = JSON.parse(fs.readFileSync(EXTENSION_PATH + file + '/extension.json', 'utf8'));

                            const dependencies = manifestJson[file].dependencies
                            if (dependencies) {
                                for (const dependency of dependencies) {
                                    let hasDependency = false

                                    for (const extDep in APP_CONFIG.extensions) {

                                        if (extDep === dependency && APP_CONFIG.extensions[extDep].active) {
                                            hasDependency = true
                                            break
                                        }
                                    }
                                    if (!hasDependency) {
                                        throw new Error(`Dependency ${dependency} is missing in extension ${file}. Please make sure that the extension ${dependency} is avtive in buildconfig.json`)
                                    }
                                }
                                console.log(dependencies)
                            }
                        } else {
                            manifestJson[file] = {name: file}
                        }

                        if (fs.existsSync(EXTENSION_PATH + file + '/build.json')) {
                            const buildOptions = require(EXTENSION_PATH + file + '/build.json')

                            // genearte source for backend
                            gensrcExtension(file, buildOptions)

                            if(buildOptions.config){
                                Object.keys(buildOptions.config).forEach(key=>{
                                    extensionConfigs[key] = buildOptions.config[key]
                                })
                                delete buildOptions.config
                            }

                            // remove hidden fields as we don't want theme to be exposed to the frontend
                            if (buildOptions.types) {
                                buildOptions.types.forEach(type => {
                                    type.fields = type.fields.filter(field => (!field.hidden || field.searchable === true || field.includeInQuery === true))
                                })
                            }

                            manifestJson[file].options = buildOptions
                        }

                        if (manifestJson[file].options && manifestJson[file].options.types) {

                            manifestJson[file].options.types.forEach(type => {

                                type.fields = type.fields.map(field => {
                                    if (field.type && COMMON_MONGO_TYPES.indexOf(field.type) < 0) {
                                        // this is a type reference
                                        field.reference = true
                                    }
                                    return field
                                })

                            })

                        }

                        /*if (fs.existsSync(extensionFolder + file + '/build.js')) {
                         const extensionBuild = require(extensionFolder + file + '/build.js')
                         const buildOptions = extensionBuild()
                         gensrcExtension(file,buildOptions)
                         }*/
                        if (fs.existsSync(EXTENSION_PATH + file + '/client-admin.js')) {
                            clientAdminContent += `import ${file} from '.${EXTENSION_PATH}${file}/client-admin.js'\nstart(${file},'${file}')\n`
                        }
                        if (fs.existsSync(EXTENSION_PATH + file + '/client.js')) {
                            if (manifestJson[file].lazyLoad) {
                                clientContent += `//load lazy
import(/* webpackChunkName: "${file}" */ '.${EXTENSION_PATH}${file}/client.js')
`
                            } else {
                                clientContent += `import ${file} from '.${EXTENSION_PATH}${file}/client.js'\nstart(${file},'${file}')\n`
                            }
                        }
                        if (fs.existsSync(EXTENSION_PATH + file + '/server.mjs')) {
                            serverContent += `import '.${EXTENSION_PATH}${file}/server.mjs'\n`
                        }


                    }
                }
            }
        }

        const manifestJsonPrivate = {}

        Object.keys(manifestJson).forEach(key => {
            manifestJsonPrivate[key] = JSON.parse(JSON.stringify(manifestJson[key]))
            if (manifestJson[key].public) {
                delete manifestJson[key].description
                delete manifestJson[key].author
                delete manifestJson[key].dependencies
                delete manifestJson[key].name
                delete manifestJson[key].public
                for(const type of manifestJson[key].options.types){
                    delete type.description
                    delete type.access
                    delete type.entryClonable
                    delete type.genResolver
                    delete type.mutationResult
                    delete type.wildcardTextIndex
                    delete type.wildcardIndex
                    for(const field of type.fields){
                        delete field.index
                        delete field.tab
                        delete field.label
                        delete field.validatePattern
                        delete field.fullWidth
                        delete field.hideColumnInTypes
                        delete field.vagueSearchable
                        delete field.vagueSearchable
                        delete field.access
                        delete field.bulkEditable
                        delete field.compoundIndex
                    }
                }
            } else {
                delete manifestJson[key]
            }
        })
        const manifestStr = `${GENSRC_HEADER}const extensions=${JSON.stringify(manifestJson, null, 2)}\nexport default extensions`

        fs.writeFile(GENSRC_PATH + "/extensions.mjs", manifestStr, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        let manifestPrivateStr = `${GENSRC_HEADER}const extensions=${JSON.stringify(manifestJsonPrivate, null, 2)}\nexport default extensions\n`

        manifestPrivateStr += `export const isExtensionEnabled = (extension)=>{return !!extensions[extension]}`

        fs.writeFile(GENSRC_PATH + "/extensions-private.mjs", manifestPrivateStr, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        fs.writeFile(GENSRC_PATH + "/extensions-client.js", clientContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })
        fs.writeFile(GENSRC_PATH + "/extensions-client-admin.js", clientAdminContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })
        fs.writeFile(GENSRC_PATH + "/extensions-server.mjs", serverContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        /* generate config */
        const config = Object.assign({}, APP_CONFIG.options, APP_VALUES)

        Object.keys(extensionConfigs).forEach(key=>{
            if(config[key]!==undefined){
                console.warn(`config key ${key} is already used and will be overriden with value used in extension`)
            }
        })

        let configContent = `${GENSRC_HEADER}export default ${JSON.stringify({...config,...extensionConfigs},null,4)}\n`
        fs.writeFile(GENSRC_PATH + "/config.mjs", configContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        // for client
        //delete config.HOSTRULES_ABSPATH
        //delete config.WEBROOT_ABSPATH
        delete config.CONFIG_ABSPATH
        delete config.BASE_POLYFILL
        delete config.STATIC_DIR
        delete config.STATIC_PRIVATE_DIR
        delete config.STATIC_TEMPLATE_DIR
        delete config.BACKUP_DIR
        delete config.UPLOAD_DIR
        delete config.UPLOAD_DIR_ABSPATH
        delete config.HTML_HEAD
        configContent = `${GENSRC_HEADER}const config = ${JSON.stringify(config,null,4)}\nmodule.exports = config\n`

        fs.writeFile(GENSRC_PATH + "/config-client.js", configContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })

        /* create schema */
        let schemaContent = `${GENSRC_HEADER}export default \`type LocalizedString {
    ${APP_CONFIG.options.LANGUAGES.join(': String\n\t')}: String
}
input LocalizedStringInput {
    ${APP_CONFIG.options.LANGUAGES.join(': String\n\t')}: String
    _localized: Boolean
}
input LocalizedRefInput {
    ${APP_CONFIG.options.LANGUAGES.join(': [ID]\n\t')}: [ID]
}\``
        fs.writeFile(GENSRC_PATH + "/schema.mjs", schemaContent, function (err) {
            if (err) {
                return console.log(err)
            }
        })


        /* ui */
        gensrcUi()


    })

}


function gensrcUi() {


    /* generate ui source */
    if (APP_CONFIG.ui) {


        const gendirUi = GENSRC_PATH + '/ui'
        try {
            fs.mkdirSync(gendirUi)
        } catch (err) {
            if (err.code !== 'EEXIST') throw err
        }


        fs.writeFile(gendirUi + "/variables.less", '', function (err) {
            if (err) {
                return console.log(err)
            }
        })

        APP_CONFIG.ui.forEach((ui) => {
            let gendirUiName = gendirUi
            if (ui.name) {
                gendirUiName += '/' + ui.name
                try {
                    fs.mkdirSync(gendirUiName)
                } catch (err) {
                    if (err.code !== 'EEXIST') throw err
                }
            }


            let uiContentIconsHooks = ''
            let uiContentIcons = `import React from 'react'\nimport Hook from 'util/hook.cjs'\n`


            //let uiContent = `${GENSRC_HEADER}import(/* webpackChunkName: "admin" */ '${ui.name?'../':''}../../client/components/ui/impl/${ui.impl || 'material'}/index')`
            //uiContent += `${GENSRC_HEADER}\nexport * from './icons'\n`

            let uiContent = `${GENSRC_HEADER}export * from 'client/components/ui/impl/${ui.impl || 'material'}/index'\nexport * from './icons'\n`


            if (ui.icons) {
                if (ui.impl === 'material') {
                    uiContentIcons += "import IconButton from '@mui/material/IconButton'\n"
                }

                //https://github.com/mui-org/material-ui/tree/v1-beta/packages/material-ui-icons/src
                ui.icons.forEach(icon => {
                    if (ui.impl === 'material') {
                        uiContentIcons += `
import ${icon}Icon from '@mui/icons-material/${icon}'
export {${icon}Icon}

export const ${icon}IconButton = React.forwardRef((props, ref) => {
    return <IconButton ref={ref} {...props}>
        <${icon}Icon />
    </IconButton>
})
`
                        uiContentIconsHooks += `components['${icon}Icon'] = ${icon}Icon\ncomponents['${icon}IconButton'] = ${icon}IconButton\n`

                    } else {
                        uiContentIcons += `
export const ${icon}Icon = ({...rest}) => {
    return <div className="Icon Icon-${icon}" {...rest} />
}
export const ${icon}IconButton = ({...rest}) => {
    return <button className="IconButton ${icon}IconButton"{...rest} >
        <${icon}Icon /> ${icon}
    </button>
}
`
                    }
                })
            }
            uiContentIcons += `Hook.on('JsonDom', ({components}) => {\n${uiContentIconsHooks}})`

            fs.writeFile(gendirUiName + '/icons.js', uiContentIcons, function (err) {
                if (err) {
                    return console.log(err)
                }
            })
            fs.writeFile(gendirUiName + "/index.js", uiContent, function (err) {
                if (err) {
                    return console.log(err)
                }
            })
        })
    }
}

function gensrcExtension(name, options) {
    if (!options) return


    const gendir = EXTENSION_PATH + name + '/' + GENSRC_PATH
    try {
        deleteFolderRecursive(path.resolve(__dirname, gendir), ['frontendhook.js','frontendAdminHook.js'])
    } catch (err) {
        if (err.code !== 'EEXIST') throw err
    }

    if (options && options.types) {


        let schema = GENSRC_HEADER + 'export default `\n'
        let resolver = GENSRC_HEADER + `import Util from '../../../api/util/index.mjs'\nimport {ObjectId} from 'mongodb'\nimport {pubsubHooked, pubsub} from '../../../api/subscription.mjs'\nimport {withFilter} from 'graphql-subscriptions'\n`
        resolver += `import Hook from '../../../util/hook.cjs'\n`
        resolver += `import {getFieldsFromGraphqlInfoSelectionSet, fieldsToArrayStructure} from '../../../api/util/graphql.js'\n`
        resolver += `import GenericResolver from '../../../api/resolver/generic/genericResolver.mjs'\n\nexport default db => ({\n`
        let resolverQuery = '\tQuery:{\n'
        let resolverMutation = '\tMutation:{\n'
        let resolverSubscription = '\tSubscription:{\n'
        let hasResolver = false, hasSchema = false
        options.types.forEach((type) => {

            const nameStartLower = type.name.charAt(0).toLowerCase() + type.name.slice(1)

            let typeSchema = 'type ' + type.name + '{\n'
            typeSchema += '\t_id: ID!' + (!type.noUserRelation ? '\n\tcreatedBy:UserPublic!' : '') + '\n\tstatus: String\n' //+'userAccess: [UserPublic]'

            let insertFields = '', cloneFields = '', updateFields = (type.noUserRelation ? '' : 'createdBy: ID'),
                resolverFields = '', refResolvers = '',
                refResolversObjectId = ''

            type.fields.forEach((field) => {

                if (field.name.trim().toLowerCase() === 'createdBy') {
                    throw Error('A filed name is not allowed. createdBy is a reserved field name')
                }


                let type = (field.type || 'String')
                let isRef = false

                if (type === 'Object') {
                    type = 'String'
                }

                if (COMMON_MONGO_TYPES.indexOf(type) < 0) {
                    // it might be a reference so we only need to store the ID
                    isRef = true
                    if (refResolvers !== '') refResolvers += ','
                    if (refResolversObjectId !== '') refResolversObjectId += ','
                    refResolvers += field.name
                    if(field.localized){
                        refResolversObjectId += field.name + ':' + '(' + field.name + '?Object.keys(' + field.name + ').reduce((acc,key)=>{acc[key]='+field.name+'[key].map(id=>new ObjectId(id)); return acc},{}):' + field.name + ')'
                    } else if (field.multi) {
                        refResolversObjectId += field.name + ':' + '(' + field.name + '?' + field.name + '.reduce((o,id)=>{o.push(new ObjectId(id));return o},[]):' + field.name + ')'
                    } else {
                        refResolversObjectId += field.name + ':' + '(' + field.name + '?' + 'new ObjectId(' + field.name + '):' + field.name + ')'
                    }
                }

                if (insertFields !== '' && !field.readOnly) insertFields += ','
                if (updateFields !== '' && !field.readOnly) updateFields += ','


                if (resolverFields !== '') resolverFields += ','

                let newInsertField = ''
                if (field.localized && field.type) {
                    typeSchema += '\t' + field.name + ': Localized'+field.type+'\n'
                    resolverFields += '\'' + field.name + '\''
                    if (!field.readOnly) {
                        newInsertField = field.name + ': LocalizedRefInput' + (field.required ? '!' : '')
                        updateFields += field.name + ': LocalizedRefInput'
                    }
                }else if (field.localized && !field.multi) { // no support for multi yet
                    typeSchema += '\t' + field.name + ': LocalizedString\n'
                    resolverFields += '\'' + field.name + '\''
                    if (!field.readOnly) {
                        newInsertField = field.name + ': LocalizedStringInput' + (field.required ? '!' : '')
                        updateFields += field.name + ': LocalizedStringInput'
                    }
                } else {
                    typeSchema += '\t' + field.name + ':' + (field.multi ? '[' : '') + (field.schemaType || type) + (field.multi ? ']' : '') + '\n'
                    resolverFields += '\'' + field.name + (isRef ? '$' + (field.multi ? '[' : '') + type + (field.multi ? ']' : '') : '') + '\''
                    if (!field.readOnly) {
                        newInsertField = field.name + ':' + (field.multi ? '[' : '') + (isRef ? 'ID' : type) + (field.multi ? ']' : '')+ (field.required ? '!' : '')
                        updateFields += field.name + ':' + (field.multi ? '[' : '') + (isRef ? 'ID' : type) + (field.multi ? ']' : '')
                    }
                }
                if (newInsertField) {
                    insertFields += newInsertField
                }

                if (field.clone!==undefined) {
                    cloneFields += ',' + newInsertField
                }
            })


            if (type.collectionClonable) {
                insertFields += ',_version:String'
                updateFields += ',_version:String'
            }

            typeSchema += '}\n\n'


            typeSchema += 'type ' + type.name + 'Result{\n\tresults:[' + type.name + ']\n\toffset:Int\n\tlimit:Int\n\ttotal:Int\n\tmeta:String\n}\n\n'

            let mutationResult = type.mutationResult
            if (!mutationResult) {
                mutationResult = type.name + 'Status'
                // if a mutationResult is set we return that otherwise we return a simple Status object

                // Maybe it is better to return only a Status instead of the whole type when create, update or delete is performed
                typeSchema += 'type ' + mutationResult + '{\n\t_id:ID!\n\tstatus:String\n' + (type.noUserRelation ? '' : '\tcreatedBy: UserPublic\n') + '}\n\n'
            }
            typeSchema += 'type Query{\n\t' + nameStartLower + 's(sort:String,limit:Int=10,offset:Int=0,page:Int=0,filter:String' + (type.collectionClonable ? ',_version:String' : '') + (type.addMetaDataInQuery ? ',meta:String' : '') + '): ' + type.name + 'Result\n}\n\n'


            typeSchema += 'type Mutation{\n'
            typeSchema += '\tcreate' + type.name + ' (' + insertFields + '):' + mutationResult + '\n'
            typeSchema += '\tupdate' + type.name + ' (_id:ID!' + (updateFields.length > 0 ? ',' : '') + updateFields + (type.addMetaDataInQuery ? ',_meta:String' : '') + '):' + mutationResult + '\n'
            typeSchema += '\tdelete' + type.name + ' (_id:ID!' + (type.collectionClonable ? ',_version:String' : '') + '):' + mutationResult + '\n'
            typeSchema += '\tdelete' + type.name + 's (_id:[ID]' + (type.collectionClonable ? ',_version:String' : '') + '):[' + mutationResult + ']\n'
            if (type.entryClonable) {
                typeSchema += '\tclone' + type.name + ' (_id:ID!' + (type.collectionClonable ? ',_version:String' : '') + cloneFields + '):' + type.name + '\n'
            }
            typeSchema += '}\n\n'

            typeSchema += 'type ' + type.name + 'SubscribeResult {\n\tdata:[' + type.name + ']\n\tremovedIds:[ID]\n\t_meta:String\n\tfilter:String\n\taction:String\n}\n\n'


            typeSchema += 'type Subscription{\n'
            typeSchema += '    subscribe' + type.name + '(filter:String): ' + type.name + 'SubscribeResult\n'
            typeSchema += '}\n\n'


            if (type.genSchema === false) {
                console.log('genSchema for type ' + type.name + ' was explicitly set to false')
            } else {
                hasSchema = true
                schema += typeSchema
            }

            if (type.genResolver === false) {
                console.log('genResolver for type ' + type.name + ' was explicitly set to false')
            } else {
                hasResolver = true

                resolverQuery += `      ${nameStartLower}s: async ({sort, limit, offset, page, filter${(type.collectionClonable ? ', _version' : '')}${(type.addMetaDataInQuery ? ', meta' : '')}}, req, graphqlInfo) => {
            const onlyRequestedFields = ${!!type.onlyRequestedFields}
            let fields
            if(onlyRequestedFields && graphqlInfo && graphqlInfo?.fieldNodes?.length>0){
                fields = fieldsToArrayStructure(getFieldsFromGraphqlInfoSelectionSet(graphqlInfo.fieldNodes[0].selectionSet.selections).results)
            }else{
                fields = [${resolverFields}]
            }
            return await GenericResolver.entities(db, req, '${type.name}', fields, {graphqlInfo, limit, offset, page, filter, sort${(type.collectionClonable ? ', _version' : '')}${(type.addMetaDataInQuery ? ', meta' : '')}})
        },\n`

                resolverMutation += `       create${type.name}: async ({${refResolvers}${refResolvers !== '' ? ',' : ''}...rest}, req, options) => {
            const result = await GenericResolver.createEntity(db, req, '${type.name}', {...rest,${refResolversObjectId}}, options)
            if(options && options.publish!==false){
              ${type.subscription === false ? '//' : ''}pubsubHooked.publish('subscribe${type.name}', {userId:req.context.id,subscribe${type.name}: {action: 'create',data:[result]}}, db, req.context)
            }
            return result
        },
        update${type.name}: async ({${refResolvers}${refResolvers !== '' ? ',' : ''}${type.noUserRelation ? '' : 'createdBy,'}_meta,...rest}, {context}, options) => {
            const result =  await GenericResolver.updateEnity(db, context, '${type.name}', {...rest,_meta,${type.noUserRelation ? '' : 'createdBy:(createdBy && createdBy.constructor===String?new ObjectId(createdBy):createdBy),'}${refResolversObjectId}}, options)
            if(options && options.publish!==false){
                ${type.subscription === false ? '//' : ''}pubsubHooked.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {_meta, action: 'update', data: [result]}}, db, context)
            }
            return result
        },
        delete${type.name}: async ({_id}, {context}) => {
            const deletedEntry = await GenericResolver.deleteEnity(db, context, '${type.name}', {_id})
            if(deletedEntry){
                ${type.subscription === false ? '//' : ''}pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'delete', removedIds: [_id]}}, db, context)
            }
            return deletedEntry
        },
        delete${type.name}s: async ({_id}, {context}) => {
            ${type.subscription === false ? '//' : ''}pubsub.publish('subscribe${type.name}', {userId:context.id,subscribe${type.name}: {action: 'delete', removedIds: _id}}, db, context)
            return GenericResolver.deleteEnities(db, context, '${type.name}', {_id})
        },\n`
                resolverSubscription += `       subscribe${type.name}: withFilter(() => pubsub.asyncIterableIterator('subscribe${type.name}'),
            async (payload, context) => {
                if( payload ) {
                    
                    const hookResponse = {}
                    if (Hook.hooks['ResolverBeforePublishSubscription'] && Hook.hooks['ResolverBeforePublishSubscription'].length) {
                        for (let i = 0; i < Hook.hooks['ResolverBeforePublishSubscription'].length; ++i) {
                            await Hook.hooks['ResolverBeforePublishSubscription'][i].callback({
                                db, payload, context, hookResponse
                            })
                        }
                    }
                    
                    if(hookResponse.abort){
                        return false
                    }
                    return await Util.userCanSubscribe(db,context,'${type.name}',payload)
                }
            }
        ),\n`

                if (type.entryClonable) {
                    resolverMutation += `       clone${type.name}: async (data, {context}) => {
            return GenericResolver.cloneEntity(db, context, '${type.name}', data)
        },\n`
                }
            }


        })
        schema += '`\n'
        resolver += resolverQuery + '\t},\n' + resolverMutation + '\t},\n' + resolverSubscription + `\t}\n})`

        if (hasSchema || hasResolver) {
            try {
                fs.mkdirSync(gendir)
            } catch (err) {
                if (err.code !== 'EEXIST') throw err
            }
            if (hasSchema) {
                fs.writeFile(gendir + "/schema.mjs", schema, function (err) {
                    if (err) {
                        console.log(err)
                    }
                })
            }
            if (hasResolver) {
                fs.writeFile(gendir + "/resolver.mjs", resolver, function (err) {
                    if (err) {
                        console.log(err)
                    }
                })
            }
        }


    }

}

const deleteFolderRecursive = function (path, skip) {
    if (fs.existsSync(path)) {
        fs.readdirSync(path).forEach(function (file, index) {
            if (skip && skip.indexOf(file) >= 0) {
                console.log(`skip file ${file}`)
            } else {
                const curPath = path + "/" + file
                if (fs.lstatSync(curPath).isDirectory()) { // recurse
                    deleteFolderRecursive(curPath, skip)
                } else { // delete file
                    console.log('delete file ' + curPath)
                    fs.unlinkSync(curPath)
                }
            }
        })
        try {
            fs.rmdirSync(path)
        } catch (e) {

        }
    }
}


module.exports = GenSourceCode
